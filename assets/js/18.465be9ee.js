(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{181:function(t,v,_){"use strict";_.r(v);var s=_(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"关于-异步-的笔记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于-异步-的笔记","aria-hidden":"true"}},[t._v("#")]),t._v(" 关于 异步 的笔记")]),t._v(" "),_("div",{staticClass:"tip custom-block"},[_("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),_("p",[t._v("涉及——"),_("br"),t._v("\n0, JavaScript 异步编程"),_("br"),t._v("\n1, setTimeout; "),_("br"),t._v("\n2, promise; "),_("br"),t._v("\n3, async/await"),_("br")])]),t._v(" "),_("h2",{attrs:{id:"javascript-异步编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript-异步编程","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript 异步编程")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("同步编程")]),t._v(" 当前代码任务耗时执行会阻塞后续代码的执行")]),t._v(" "),_("li",[_("strong",[t._v("异步编程")]),t._v(" 在等待当前任务的响应返回之前，可以继续执行后续代码，即当前执行的任务不会阻塞后续执行")])]),t._v(" "),_("p",[t._v("在 JS 中，阻塞就意味着不能处理其他任务（譬如页面的交互，滚动等操作），所以对于耗时操作，往往要采取异步编程的方式")]),t._v(" "),_("p",[t._v("通常实现异步的方式是 多线程。但是 JS 语言执行环境是单线程的（为了避免多个线程竞争修改同个 DOM 元素等情况）。JS 引擎负责解析，执行 JS 代码，但是它不能单独运行，通常都得有一个宿主环境，一般如浏览器或Node服务器，前文说到的单线程是指在这些宿主环境创建单一线程"),_("br")]),t._v(" "),_("p",[_("strong",[t._v("并行和并发的区别")]),_("br")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("并行")]),t._v(" 同一时刻内多任务同时进行")]),t._v(" "),_("li",[_("strong",[t._v("并发")]),t._v(" 同一时间段内，多个任务同时进行，但是某一时刻，只有某一任务执行")])]),t._v(" "),_("p",[t._v("注：我们通常说到的并发连接数，是指浏览器向服务器发起请求，建立 TCP 链接，每秒钟服务器建立的总连接数，譬如，服务器每10ms能处理一个连接，那么其并发连接数就是100")]),t._v(" "),_("p",[t._v("JS 单线程异步编程可以实现多任务"),_("strong",[t._v("并发")]),t._v("执行")]),t._v(" "),_("p",[_("strong",[t._v("基于事件循环的并发模型")]),_("br"),t._v(" "),_("strong",[t._v("事件循环 Event Loop")]),_("br")]),t._v(" "),_("ul",[_("li",[t._v("消息队列")]),t._v(" "),_("li",[t._v("执行栈")])])])}],!1,null,null,null);r.options.__file="09.md";v.default=r.exports}}]);