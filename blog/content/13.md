# GO 语言开发规范

:::tip
来自编程猫<br>
:::

## 通用规范

- 方法名，变量名，类名等的命名，必须反映出相应的业务含义，需要见名知意。
- 静态（变量/常量）必须大写，并且单词之间用下划线隔开。
- 不允许使用魔法数字，需要定义常量（普通常量或枚举）。
- 会经常改变的常量，需要写到配置文件（或DB）中，禁止直接在代码中进行硬编码。
- 单个方法的代码不宜超过100行， 超过200行的必须重构。
- 单个文件行数需要控制在1000行以下。
- while或if 等嵌套查询复杂度不容许超过3层。 if 条件能一次判断的，不要嵌套方式分多次判断。
- if-else if--else 语句超过8个的必须重构，可以采用策略模式、状态模式、map等方式实现。
- 判断语句非常复杂的(不宜超过4个），必须抽取成方法，提高可读性。
- 修改代码的时候，看一下该代码的注释是否也需要一起修改，必须保持代码和注释的一致性，不然注释不但无用，反而可能误导人。（修改时，注释需要加修改人，更新说明、更新时间）
- 对于使用了特殊技巧的代码， 不是那么容易一眼看明白的，必须写明大体设计思路和代码技巧说明。
- 对于从网上copy下来的代码，必须先读懂代码并测试验证其正确性， 然后对代码的实现，进行一定的重构，以满足我们的开发规范。 （因为网上的代码很多只是为了展示其解决方案而编写比较随意的代码，不是生产级别的代码，会存在很多问题)

## go fmt

大部分的格式问题可以通过 gofmt 解决，gofmt 自动格式化代码，保证所有的Go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。
代码提交前，必须执行gofmt进行格式化。Vs code会在每次保存时执行一次格式化

## go vet

vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。
代码提交前，必须执行go ver进行静态检查。

## 长度约定

- 代码块长度，比如约定超过50行就需要考虑优化。
- 行代码长度控制，太长的需换行，提高代码可读性。

## 注释

- 对外（Public）的结构体、函数和包必须进行注释
- 结构体注释格式：

```go
// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
type ObjectMeta struct {
}
```

- 函数注释格式：

```go
// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
}
```

- 包注释格式：

```go
// Package path implements utility routines for
// manipulating slash-separated filename paths.
path
```

## 消息命名

- 前端发送给后端的消息以 C2S_ 开头（？）
- 后端发送给前端的消息以 S2C_ 开头（？）

## 命名

- 关键或者复杂的代码需要进行注释
- 注释内容必须是可读的完整句子，简要并且突出重点。 
- 需要注释来补充的命名就不算是好命名。
- 使用可搜索的名称：单字母名称和数字常量很难从一大堆文字中搜索出来。单字母名称仅适用于短方法中的本地变量，名称长短应与其作用域相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。
- 做有意义的区分：Product 和 ProductInfo 和 ProductData 没有区别，NameString 和 Name 没有区别，要区分名称，就要以读者能鉴别不同之处的方式来区分 。
- 函数命名规则：驼峰式命名，名字可以长但是得把功能，必要的参数描述清楚，函数名名应当是动词或动词短语，不可导出的函数以小写开头。

如 postPayment、deletePage、save。并依 Javabean 标准加上 get、set、is 前缀。例如：xxx + With + 需要的参数名 + And + 需要的参数名 + …..

- 结构体命名规则：结构体名应该是名词或名词短语，如 Custome、WikiPage、Account、AddressParser
- 接口命名规则：
单个函数的接口名以"er"作为后缀，如Reader,Writer
接口的实现则去掉“er”

```go
type Reader interface {
  Read(p []byte) (n int, err error)
}
```

两个函数的接口名综合两个函数名<br>
```go
type WriteFlusher interface {
  Write([]byte) (int, error)
  Flush() error
}
```

三个以上函数的接口名，类似于结构体名<br>
```go
type Car interface {
  Start([]byte)
  Stop() error
  Recover()
}
```

## 包

- 包名命名规则：包名应该为小写单词，不要使用下划线或者混合大小写。
- 文件夹命名规则：小写单词，使用横杠连接
- 文件命名 规则：小写单词，使用下划线连接，测试文件_test.go结束
- 一般情况下包名和文件夹命名是一致的，不过也可以不一样

## 常量

常量均需使用全部大写字母组成，并使用下划线分词：<br>
```go
const APP_VER = "1.0"
```

如果是枚举类型的常量，需要先创建相应类型：<br>
```go
type Scheme string
const (
  HTTP  Scheme = "http"
  HTTPS Scheme = "https"
)
```

## 变量

变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：<br>
- 如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient
- 其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID
- 错误示例：UrlArray，应该写成 urlArray 或者 URLArray

若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头：<br>
```go
var isExist boolvar hasConflict bool
var canManage bool
var allowGitHook bool
```

多个变量声明放在一起<br>
```go
var (
  isExist bool
  count int
)
```

在函数外部声明使用var,不要采用:=

## struct

声明和初始化采用多行，初始化结构体使用带有标签的语法<br>
```go
type User struct{
  Username  string
  Email     string
}
```
```go
u := User{
  Username: "yourname",
  Email:    "yourname@gmail.com",
}
```

修改对象属性不能直接使用赋值，要写成方法且必须加锁<br>
结构体中的私有变量用m_开头,导出变量直接大写字母开头<br>

## map

非线程安全，并发读写map的情况下必须加锁，不然会产生panic除非确定不会并发访问,要不然使用sync.Map

## 函数

函数采用命名的多值返回，传入变量和返回变量以小写字母开头

```go
func nextInt(b []byte, pos int) (value, nextPos int)
```

函数返回值可能为空或零值时，最好加一个逻辑判断的返回值<br>
```go
func Foo(a int, b int) (string, bool)
```

函数返回用显式，不要用隐式，避免返回值被重复定义，导致返回值错误，特别是error返回值<br>
```go
func Foo() (bar *Bar,err error){
  a,err:=A()
  if err !=  nil{
      return
  }
  ...
  return
}
```

约定下面的写法<br>
```go
func Foo() (bar *Bar,err error){
  a,err:=A()
  if err !=  nil{
      return nil,err
  }
  ...
  return bar,nil
}
```

## init

- 在同一个文件中，可以重复定义init方法
- 在同一个文件中，多个init方法按照在代码中编写的顺序依次执行
- 在同一个package中，可以多个文件中定义init方法
- 在同一个package中，不同文件中的init方法的执行按照文件名先后执行各个文件中的init方法

建议同一个文件中只定义一个init方法，同一个package中init尽量合并

## 错误处理

- error作为函数的值返回,必须对error进行处理
- 错误描述如果是英文必须为小写，不需要标点结尾
- 采用独立的错误流进行处理

不要采用下面的处理错误写法:<br>
```go
if err != nil {
    // error handling
} else {
    // normal code
}
```

采取下面的写法<br>
```go
if err != nil {
    // error handling
    return // or continue, etc.
}
// normal code
```

使用函数返回值时，则采用下面的方式<br>
```go
x, err := f()
if err != nil {
    // error handling
    return
}
// use x
```

## 控制结构

if 接受初始化语句，约定如下方式建立局部变量<br>
```go
if err := file.Chmod(0664); err != nil {
  return err
}
```

for 采用短声明建立局部变量<br>
```go
sum := 0
for i := 0; i < 10; i++ {
  sum += i
}
```

range<br>
如果只需要第一项(key)，则丢弃第二个<br>
```go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
```

如果只需要第二项，则把第一项置为下划线<br>
```go
sum := 0
for _, value := range array {
    sum += value
}
```

return 尽早 return；一旦有错误发生，马上返回<br>
```go
f, err := os.Open(name)
if err != nil {
  return err
}

d, err := f.Stat()
if err != nil {
  f.Close()
  return err
}
codeUsing(f, d)
```

## panic

在逻辑处理中不要使用panic，且业务逻辑中要有recover机制

## import

对 import 的包进行分组管理，用换行符分割，而且标准库作为分组的第一组。如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包。<br>
```go
package main
 
import (
  "fmt"
  "os"

  "kmg/a"
  "kmg/b"

  "code.google.com/a"
  "github.com/b"
)
```

在项目中不要使用相对路径引入包：<br>
// 错误示例<br>
```go
import "../net"
```

// 正确做法<br>
```go
import "github.com/repo/proj/src/net"
```

## 参数传递

- 对于少量数据，不要传递指针
- 对于大量数据的 struct 可以考虑使用指针
- 传入的参数是 map，slice，chan 不要传递指针，因为 map，slice，chan 是引用类型，不需要传递指针的指针

## 单元测试

单元测试文件名命名规范：<br>
`example_test.go`<br>
测试用例的函数名称必须以 Test 开头，例如：<br>
```go
func TestExample(t * testing.T)
```

性能测试：<br>
函数名以Benchmark开头<br>
```go
func BenchmarkExample(b *testing.B)
```

## 日志

- 为了方便日志分析，记录日志统一使用glog或项目自己定义的log包
- 记录有意义的日志，日志里记录一些比较有意义的状态数据：程序启动，退出的时间点；程序运行消耗时间；耗时程序的执行进度；重要变量的状态变化。
- 日志内容必须是可读的英文语句，第一个单词首字母大写，合理标点符号

```bash
glog.V(2).Infof("Skipping nil field: %s", key)
glog.Errorf("Failed to changes docker version to docker apiverson: %v", err)
glog.Fatalf("Error compiling: %v", err)
```

- 错误日志必须日志打印：<br>
```go
_, err := serverFailureDetector.Detect()
if err != nil {
   glog.Errorf("Failed to detect server failure, %v", err)
   return
}
```

- 日志等级<br>
等级	方法	说明<br>
- Fatal	glog.Fatal	致命的异常，造成服务中断的错误, 一般只在程序初始化校验阶段使用
- Error	glog.Error	异常，其他错误运行期错误；
- Warning	glog.Warning	警告，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；
- Info	glog.Info	有意义的信息，如程序启动，关闭事件，收到请求事件等；
- Debug	glog.V(2).Info	调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；
- Trace	glog.V(5).Info	更详细的跟踪信息；

## 依赖包

依赖包统一用govendor管理，详情参考依赖包管理<br>
本文档以以下文档为原型修改而成 [Golang编程规范](rhttps://blog.csdn.net/wlhdo71920145/article/details/81092697)