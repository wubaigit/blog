# 图片中插入数据

:::tip
2018年12月26日<br>
讲一讲工作上遇到过的解码问题
:::

工作中遇到一个需求调研，要求往图片文件数据中插入一段数据，不改变图片显示情况，同时,要求当用户上传这张图片的时候，我们能够从中获取数据。<br>

**第一步，借用 `HTMLCanvasElement.toDataURL` 去生成一个 Base64 编码的图片数据<br>**

```ts
import * as canvg from 'canvg-browser';
/**
 * canvg 的 README——
 *  canvg是一个SVG解析器和渲染器。
 *  它获取SVG文件的URL或SVG文件的文本，
 *  在JavaScript中解析它，
 *  并在Canvas元素上呈现结果。
 *  示例的渲染速度与本机SVG一样快。
 */

const generateImage = async() => {
  const canvas = document.createElement('canvas');
  document.body.appendChild(canvas);
  const xmlData = `<svg viewBox="0 0 100 100" width="100" height="100">
    <image xlink:href="https://raw.githubusercontent.com/wubaigit/wubai-blog/master/blog/assets/07/20-owl.png"
      width="100" height="100"/>
  </svg>`;
  const completeRenderCanvas = await getCanvasWhenRenderCompletely(canvas, xmlData);
  const canvasBase64 = completeRenderCanvas.toDataURL('image/png');
  document.body.removeChild(canvas);
  return canvasBase64;
}
const getCanvasWhenRenderCompletely = (canvas:HTMLCanvasElement, xmlData:string) => {
  return new Promise((resolve: (res: HTMLCanvasElement) => void) => {
    canvg(canvas, xmlData, {
      renderCallback: () => {
        resolve(canvas);
      }
    });
  });
}
```

svg图片如下——

<svg viewBox="0 0 100 100" width="100" height="100">
  <image xlink:href="https://raw.githubusercontent.com/wubaigit/wubai-blog/master/blog/assets/07/20-owl.png"
    width="100" height="100"/>
</svg>

**第二步，插入数据<br>**
HTMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。<br>
Data URLs 由四个部分组成：前缀 `data` ，指示数据类型的 `MIME` 类型，如果为非文本则为可选的 `base64` 标记，数据本身: `data:[<mediatype>][;base64],<data>`<br>
这个 `<data>` 部分才是这个文件二进制数据的 Base64编码<br>

关于 Base64 编码 [Base64究竟是一个什么东西](./08.md)

```ts
const generatePNGWithInfo = (base64Code:string, info:string) => {
  const head = `data:image/png;base64,`;
  const fileBase64Code = base64Code.slice(head.length);
  const fileBase64CodeBuffer = base64ToUint8Array(fileBase64Code);
  const encodeInfo = encodeURI(info); // 为了避免 info 中的一些诸如中文的数据
  const insertInfoBuffer = stringToUint8Array(encodeInfo);
  const newBuffer = concatUint8Array(fileBase64CodeBuffer, insertInfoBuffer);
  const res = head + Uint8ArrayToBase64(newBuffer);
  return res;
};

const base64ToUint8Array = (base64:string) => {
  const binaryString = window.atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
};

const stringToUint8Array = (str:string) => {
  const bufView = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return bufView;
};

const concatUint8Array = (buffer1:Uint8Array, buffer2:Uint8Array) => {
  const tmp = new Uint8Array(buffer1.length + buffer2.length);
  tmp.set(buffer1, 0);
  tmp.set(buffer2, buffer1.length);
  return tmp;
};

const Uint8ArrayToBase64 = (buffer:Uint8Array) => {
  let binary = '';
  const len = buffer.length;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(buffer[i]);
  }
  return window.btoa(binary);
};
```

**第三步，生成的新的图片显示在网页上，然后下载下来，再上传上去<br>**

**第四步，读取上传文件中的数据<br>**
```ts
const readInfoFromPNG = async (file: File) => {
  return new Promise((resolve: (res: string) => void) => {
    const reader = new FileReader();
    reader.addEventListener('load', (event: any) => {
      const result = event.target.result;
      const resDataView = new DataView(result);
      const info = read(resDataView)
      resolve(info);
    });
    reader.readAsArrayBuffer(file);
  });
}

const read = (dv: DataView) => {
  /**
   * 前面8个字节是署名域，用来识别该文件是不是 PNG 文件
   * 随后是数据块，每个数据块包含
   *  1. Length（长度）4字节
   *  2. Chunk Type Code（数据块类型码）4字节
   *  3. Chunk Data（数据块实际内容）可变
   *  4. CRC（循环冗余检测）4字节
   */
  let pos = 8;
  const readNameAndLengthOfChunk = () => {
    const length = dv.getUint32(pos);
    let name = '';
    pos += 4;
    for (let i = 0; i < 4; i++) {
      name += String.fromCharCode(dv.getUint8(pos));
      pos += 1;
    }
    return {
      name, length,
    };
  };
  while (true) {
    const { name, length } = readNameAndLengthOfChunk();
    const crcLength = 4;
    pos = pos + length + crcLength;
    if (name === 'IEND') {
      break;
    }
  }
  const dvLen = dv.byteLength;
  let info = '';
  for (let i = pos; i < dvLen; i += 1) {
    info += String.fromCharCode(dv.getUint8(i));
  }
  return decodeURI(info);
}
```

:::tip
经过调研——<br>
经过一般的压缩算法之后，数据会丢失；<br>
微信传输不会丢失数据；<br>
上传到 七牛 之后，下载下来的也是阉割版的<br>
:::

资料：

[javascript charCodeAt() 和 fromCharCode()](https://blog.csdn.net/hongweigg/article/details/6826517)

[通过 javascript 进行 utf-8 编码](https://segmentfault.com/a/1190000005794963)

[ArrayBuffer to base64](https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string)

[使用 JavaScript 把 ArrayBuffer 做 base64 編碼](https://kheresy.wordpress.com/2013/09/02/some-method-to-encode-arraybuffer-as-base64/)

[PNG 文件格式详解](https://blog.mythsman.com/2015/12/08/1/)

[Javascript (or pseudocode) to properly append two PNGs using arraybuffers/canvas](https://stackoverflow.com/questions/37904104/javascript-or-pseudocode-to-properly-append-two-pngs-using-arraybuffers-canvas)

[文件上传的那些事](https://juejin.im/entry/590ad4682f301e00582a78b5)

